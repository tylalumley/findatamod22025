# -*- coding: utf-8 -*-
"""Copy of DCF1 WACC - TYLA LUMLEY.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PfpBi9u7pWULAXd9J_hRpRAdekc7wx7w

# DCF Part 1: WACC

In this notebook, we will compute the weighted average cost of capital.

$WACC = w_E * k_E + w_D * k_D * (1-t)$

Steps to get there:
1. Get firm data to compute Equity and Debt weights ($w_E$ and $w_D$)
2. Compute the cost of equity using the CAPM: $k_E = r_f + B_i * EMRP$

We'll get the risk free rate from market data.
We'll use an OLS regression to compute our own Beta.
The EMRP we will take as given.

3. Compute the cost of debt: $k_D = r_f + spread$

The $spread$ is the default spread given a firm's credit rating. We'll use a lookup table using current data to get the spread.

4. $t$ is the marginal tax rate, which we'll take as 25%.
5. Put it all together!

This is our in-class project that we will work on progressively through the mod.

Expectations:
1. Notebook is clean and neat, with no repeated code. It has clearly labeled sections for inputs/imports at the beginning. Code is sufficiently commented to demonstrate your understanding of the code and help you or anyone else who may use this code later. All numbers should be formatted so they are readable (so, use commas with large numbers, only a few decimal points).
2. All calculations are correct and all discussion questions are answered completely but concisely, demonstrating a depth of understanding.

Workflow:
1. Notebooks are inherently experimental and allow you to try things, however that requires some good habits
2. Once you are "done" in any sense, you always need to "clean up" your notebook to make it presentable. You'd do the same in Excel - you've tried lots of things, etc. but before you present it, you clean it up.
3. Finally, restart the Runtime/Kernel and run it cleanly all the way top to bottom one time.

Then, its ready to go.

# 1 Always put Imports and Installs at the beginning

And only put them in once.

Set display options here if you are using them.

Set API Keys here if you need them.
"""

# necessary imports
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import statsmodels.api as sm
import yfinance as yf

# Format setting for the model - tame the decimals!
pd.reset_option('display.float_format')
pd.set_option('display.float_format', lambda x:'{:,.2f}'.format(x))

# Commented out IPython magic to ensure Python compatibility.
# # install the FRED API for economic data
# # This is necessary since Google Colab does not have this package installed already
# %%capture
# !pip install fredapi

# import
import fredapi
# These two lines set the API Key so you can access FRED data with your credentials
from google.colab import userdata
fred = fredapi.Fred(api_key=userdata.get('FRED_APIKey'))

"""# 2 Gather inputs, assumptions, parameters at the beginning

This is a place for anything that you may want to change in the future. The rest of the notebook should just be code that runs, generating the necessary output, plots, etc.

### Assumptions and paramters

"""

# Set Ticker we are modeling
ticker_symbol = 'MSFT'
company_name = "Microsoft"
firm_rating = "Aaa/AAA"

# choose the "market" for our beta - get from Yahoo! Finance
index_symbol = '^GSPC'
index_name = "S&P 500"

# get risk free rate from FRED
# first, get the whole series
rf_series = fred.get_series('GS10')
# then,

# get the most recent value, divide by 100 to make it a decimal like all others
rf = rf_series.iloc[-1]/100
#print the risk free rate
print(f'Risk free rate : {rf:,.2%}')
emrp = 0.05 # given
marg_tax_rate = 0.25 # for WACC, given

# this is what we divide numbers by, 1000000 is $M
scale_factor = 1000000
scale_name = '$M'

"""# 3 Begin Calculations and Modeling

**From here, nothing should be hardcoded**

## Debt and Equity Weights
"""

# Create a Ticker object from Yahoo
ticker = yf.Ticker(ticker_symbol)


# Get the market cap and total debt (use the right scale factor)
market_cap = ticker.info.get('marketCap') / scale_factor
total_debt = ticker.info.get('totalDebt') / scale_factor


print(f"Market Capitalization for {ticker_symbol}: {market_cap:,.2f}")
print(f"Total Debt for {ticker_symbol}: {total_debt:,.2f}")

# compute equity and debt weights
w_E = market_cap / (market_cap + total_debt)
w_D = total_debt / (market_cap + total_debt)

print(f"Equity Weight for {ticker_symbol}: {w_E:,.2f}")
print(f"Debt Weight for {ticker_symbol}: {w_D:,.2f}")

"""## Cost of Equity

Really this is just beta because the other two are either given or looked up already.
"""

# Download historical data for the firm and S&P 500
# get five years of monthly data
stock_data = yf.download(ticker_symbol, period='5y', interval='1mo')["Close"]
index_data = yf.download(index_symbol, period='5y', interval='1mo')["Close"]

# Calculate monthly returns for stock and S&P 500, and subtract off the risk free rate
stock_returns = stock_data.pct_change().dropna() - rf
index_returns = index_data.pct_change().dropna() - rf

# Run OLS regression, be sure to add a constant to index returns
# this will use the statsmodels package (don't forget to import above...)
X = sm.add_constant(index_returns)
model = sm.OLS(stock_returns, X)
results = model.fit()

# Print out the regression results
print(results.summary())

# Get the beta - it is the coefficient on the index return, not the constant
beta = results.params[index_symbol]

#get the second item in the list of parameters
#or beta = results.params.iloc[1]

# Print the beta
print(f"Beta for {ticker_symbol}: {beta:.2f}")

# Calculate the cost of equity using CAPM
cost_of_equity = rf + beta * emrp

# Print the cost of equity

print(f"Cost of Equity for {ticker_symbol}: {cost_of_equity:.2%}")

"""## Cost of Debt

Really, just the spread is all we need.

I have a table that I like to use from Aswath Damodaran.
[Here is the link.](https://people.stern.nyu.edu/adamodar/New_Home_Page/datafile/ratings.html)


I updated it with the following prompt in ChatGPT:

*I have the following list structure for credit spreads in python:*

```
Paste old code table here
```
*Please update it with this new data (copied from a web site):*
```
Paste unformatted table text from Damodaran's website here
```

And that seems to work





"""

# Updated default spreads for large non-financial service firms
# Source: Latest web data (2025)
credit_spreads = [
    {"GreaterThan": -100000, "LessThan": 0.199999, "Rating": "D2/D", "Spread": 19.00},
    {"GreaterThan": 0.2, "LessThan": 0.649999, "Rating": "C2/C", "Spread": 15.50},
    {"GreaterThan": 0.65, "LessThan": 0.799999, "Rating": "Ca2/CC", "Spread": 10.10},
    {"GreaterThan": 0.8, "LessThan": 1.249999, "Rating": "Caa/CCC", "Spread": 7.28},
    {"GreaterThan": 1.25, "LessThan": 1.499999, "Rating": "B3/B-", "Spread": 4.42},
    {"GreaterThan": 1.5, "LessThan": 1.749999, "Rating": "B2/B", "Spread": 3.00},
    {"GreaterThan": 1.75, "LessThan": 1.999999, "Rating": "B1/B+", "Spread": 2.61},
    {"GreaterThan": 2.0, "LessThan": 2.2499999, "Rating": "Ba2/BB", "Spread": 1.83},
    {"GreaterThan": 2.25, "LessThan": 2.49999, "Rating": "Ba1/BB+", "Spread": 1.55},
    {"GreaterThan": 2.5, "LessThan": 2.999999, "Rating": "Baa2/BBB", "Spread": 1.20},
    {"GreaterThan": 3.0, "LessThan": 4.249999, "Rating": "A3/A-", "Spread": 0.95},
    {"GreaterThan": 4.25, "LessThan": 5.499999, "Rating": "A2/A", "Spread": 0.85},
    {"GreaterThan": 5.5, "LessThan": 6.499999, "Rating": "A1/A+", "Spread": 0.77},
    {"GreaterThan": 6.5, "LessThan": 8.499999, "Rating": "Aa2/AA", "Spread": 0.60},
    {"GreaterThan": 8.5, "LessThan": 100000, "Rating": "Aaa/AAA", "Spread": 0.45}
]

"""Here we are going to write a function. Remember, we'll do this in two overall steps:

1. Write a script (not a function) that does what you want it to do and check and be sure that all the logic works.
2. Turn that script into a function with inputs and outputs, etc.
"""

# write a function. It should take two inputs:
# 1. rating, a string variable that represents the firm's credit rating
# 2. credit_spreads, a list of dictionaries that has a lookup table from Damodaran's website.
# The table is in the above cell.
#
# The output should return a credit spread, which is a float data type.
# If no match is found, it should print a warning and return a NaN
def get_credit_spread(rating, credit_spreads):
    """
    Returns the credit spread (float) for a given credit rating.

    Parameters:
        rating (str): Firm's credit rating (e.g., 'A2/A', 'Baa2/BBB')
        credit_spreads (list): List of dictionaries containing rating and spread data.

    Returns:
        float: The credit spread as a numeric value.
               Returns math.nan if no match is found.
    """
    for entry in credit_spreads:
        if entry["Rating"].strip().lower() == rating.strip().lower():
            return float(entry["Spread"])/100

    print(f"Warning: No spread found for rating '{rating}'. Returning NaN.")
    return np.nan

# Example usage
credit_spread = get_credit_spread(firm_rating, credit_spreads)

print(f"The spread for {ticker_symbol}'s rating ({firm_rating}) is: {credit_spread:.2%}")

# compute cost of debt: risk free rate plus credit spread
cost_of_debt = rf + credit_spread

print(f"Cost of Debt for {ticker_symbol}: {cost_of_debt:.2%}")

"""## Finally, compute the WACC

put it all together
"""

# Calculate WACC
wacc = (w_E * cost_of_equity) + (w_D * cost_of_debt * (1- marg_tax_rate))

print(f"WACC for {ticker_symbol}: {wacc:.2%}")

"""# Homework: What about Uncertainty?

Our estimate of beta has a range of uncertainty about it - a 95% confidence interval.

**HOMEWORK**

1. Go back to the OLS above and find the lower and upper CI for beta. Do this programmatically (i.e., find it in the `results` object)
2. Recompute a *lower* and *upper* WACC based on that *lower* and *upper* beta

If you are completely stuck, you should hard code the upper and Lower CI so you can turn this in, but there will be a deduction.

Expected output: A DataFrame, one column, three rows, with the Lower CI, the Estimate, and Upper CI version of the WACC, in that order.
"""

#Upper and lower Beta estimates
beta_lower = results.conf_int().loc["^GSPC", 0]
beta_upper = results.conf_int().loc["^GSPC", 1]

print(f"The lower Beta estimate is equal to: {beta_lower}")
print(f"The upper Beta estimate is equal to: {beta_upper}")

#New WACC upper and lower calculations
wacc_lower = rf + beta_lower * emrp
wacc_upper = rf + beta_upper * emrp

print(f"The lower WACC estimate is equal to: {wacc_lower}")
print(f"The upper WACC estimate is equal to: {wacc_upper}")

wacc_df = pd.DataFrame({
    "WACC": [wacc_lower, wacc, wacc_upper]
}, index=["Lower CI", "Estimate", "Upper CI"])

wacc_df

